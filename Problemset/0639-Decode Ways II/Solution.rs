impl Solution {
    pub fn num_decodings(s: String) -> i32 {
        let s = s.as_bytes();
        let mut dp = vec![[0_i64; 2]; s.len()];

        match s[0] {
            b'0' => return 0,
            b'*' => dp[0][0] = 9,
            _ => dp[0][0] = 1,
        }

        if s.len() > 1 {
            dp[1] = match (s[0], s[1]) {
                (b'1', b'0') => [0, 1],
                (b'1', b'*') => [9, 9],
                (b'1', _) => [1, 1],
                (b'2', b'0') => [0, 1],
                (b'2', b'*') => [9, 6],
                (b'2', x) if x < b'7' => [1, 1],
                (b'2', _) => [1, 0],
                (b'*', b'0') => [0, 2],
                (b'*', b'*') => [81, 15],
                (b'*', x) if x < b'7' => [9, 2],
                (b'*', _) => [9, 1],
                (_, b'0') => [0, 0],
                (_, b'*') => [9, 0],
                _ => [1, 0],
            };
        }

        for i in 2..s.len() {
            dp[i][0] = match s[i] {
                b'0' => 0,
                b'*' => 9 * (dp[i - 1][0] + dp[i - 1][1]),
                _ => dp[i - 1][0] + dp[i - 1][1],
            } % 1_000_000_007;

            dp[i][1] = match (s[i - 1], s[i]) {
                (b'1', b'*') => 9 * (dp[i - 2][0] + dp[i - 2][1]),
                (b'1', _) => dp[i - 2][0] + dp[i - 2][1],
                (b'2', b'*') => 6 * (dp[i - 2][0] + dp[i - 2][1]),
                (b'2', x) if x < b'7' => dp[i - 2][0] + dp[i - 2][1],
                (b'*', b'*') => 15 * (dp[i - 2][0] + dp[i - 2][1]),
                (b'*', x) if x < b'7' => 2 * (dp[i - 2][0] + dp[i - 2][1]),
                (b'*', _) => dp[i - 2][0] + dp[i - 2][1],
                _ => 0,
            } % 1_000_000_007;
        }

        ((dp[dp.len() - 1][0] + dp[dp.len() - 1][1]) % 1_000_000_007) as i32
    }
}
