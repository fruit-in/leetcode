# 1337. 方阵中战斗力最弱的 K 行
给你一个大小为 ```m * n``` 的方阵 ```mat```，方阵由若干军人和平民组成，分别用 0 和 1 表示。

请你返回方阵中战斗力最弱的 ```k``` 行的索引，按从最弱到最强排序。

如果第 ***i*** 行的军人数量少于第 ***j*** 行，或者两行军人数量相同但 ***i*** 小于 ***j***，那么我们认为第 ***i*** 行的战斗力比第 ***j*** 行弱。

军人 **总是** 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。

#### 示例 1:
<pre>
<strong>输入:</strong> mat =
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]],
k = 3
<strong>输出:</strong> [2,0,3]
<strong>解释:</strong>
每行中的军人数目：
行 0 -> 2
行 1 -> 4
行 2 -> 1
行 3 -> 2
行 4 -> 5
从最弱到最强对这些行排序后得到 [2,0,3,1,4]
</pre>

#### 示例 2:
<pre>
<strong>输入:</strong> mat =
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]],
k = 2
<strong>输出:</strong> [0,2]
<strong>解释:</strong>
每行中的军人数目：
行 0 -> 1
行 1 -> 4
行 2 -> 1
行 3 -> 1
从最弱到最强对这些行排序后得到 [0,2,3,1]
</pre>

#### 提示:
* ```m == mat.length```
* ```n == mat[i].length```
* ```2 <= n, m <= 100```
* ```1 <= k <= m```
* ```matrix[i][j]``` 不是 0 就是 1

## 题解 (Rust)

### 1. 排序
```Rust
impl Solution {
    pub fn k_weakest_rows(mat: Vec<Vec<i32>>, k: i32) -> Vec<i32> {
        let mat = mat.iter().map(|r| r.iter().sum()).collect::<Vec<i32>>();
        let mut ret = (0..(mat.len() as i32)).collect::<Vec<i32>>();
        ret.sort_by_key(|&k| mat[k as usize]);

        ret[..(k as usize)].to_vec()
    }
}
```
