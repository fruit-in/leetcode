# 928. 尽量减少恶意软件的传播 II
给定一个由 `n` 个节点组成的网络，用 `n x n` 个邻接矩阵 `graph` 表示。在节点网络中，只有当 `graph[i][j] = 1` 时，节点 `i` 能够直接连接到另一个节点 `j`。

一些节点 `initial` 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。

假设 `M(initial)` 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。

我们可以从 `initial` 中 **删除一个节点**，**并完全移除该节点以及从该节点到任何其他节点的任何连接**。

请返回移除后能够使 `M(initial)` 最小化的节点。如果有多个节点满足条件，返回索引 **最小的节点** 。

#### 示例 1:
<pre>
<strong>输入:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>输出:</strong> 0
</pre>

#### 示例 2:
<pre>
<strong>输入:</strong> graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
<strong>输出:</strong> 1
</pre>

#### 示例 3:
<pre>
<strong>输入:</strong> graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
<strong>输出:</strong> 1
</pre>

#### 提示:
* `n == graph.length`
* `n == graph[i].length`
* `2 <= n <= 300`
* `graph[i][j]` 是 `0` 或 `1`.
* `graph[i][j] == graph[j][i]`
* `graph[i][i] == 1`
* `1 <= initial.length < n`
* `0 <= initial[i] <= n - 1`
* `initial` 中每个整数都**不同**

## 题解 (Rust)

### 1. 题解
```Rust
impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let n = graph.len();
        let mut min_infected = n;
        let mut ret = initial[0];

        for &removed in &initial {
            let mut is_infected = vec![false; n];
            let mut stack = vec![];
            let mut count = 0;

            for &i in &initial {
                if i != removed {
                    is_infected[i as usize] = true;
                    stack.push(i as usize);
                    count += 1;
                }
            }

            while let Some(i) = stack.pop() {
                for j in 0..n {
                    if graph[i][j] == 1 && !is_infected[j] && j != removed as usize {
                        is_infected[j] = true;
                        stack.push(j);
                        count += 1;
                    }

                    if count > min_infected {
                        break;
                    }
                }

                if count > min_infected {
                    break;
                }
            }

            if count < min_infected || (count == min_infected && removed < ret) {
                min_infected = count;
                ret = removed;
            }
        }

        ret
    }
}
```
