# 1922. 统计好数字的数目
我们称一个数字字符串是 **好数字** 当它满足（下标从 **0** 开始）**偶数** 下标处的数字为 **偶数** 且 **奇数** 下标处的数字为 **质数** （`2`，`3`，`5` 或 `7`）。

* 比方说，`"2582"` 是好数字，因为偶数下标处的数字（`2` 和 `8`）是偶数且奇数下标处的数字（`5` 和 `2`）为质数。但 `"3245"` **不是** 好数字，因为 `3` 在偶数下标处但不是偶数。

给你一个整数 `n` ，请你返回长度为 `n` 且为好数字的数字字符串 **总数** 。由于答案可能会很大，请你将它对 <code>10<sup>9</sup> + 7</code> **取余后返回** 。

一个 **数字字符串** 是每一位都由 `0` 到 `9` 组成的字符串，且可能包含前导 0 。

#### 示例 1:
<pre>
<strong>输入:</strong> n = 1
<strong>输出:</strong> 5
<strong>解释:</strong> 长度为 1 的好数字包括 "0"，"2"，"4"，"6"，"8" 。
</pre>

#### 示例 2:
<pre>
<strong>输入:</strong> n = 4
<strong>输出:</strong> 400
</pre>

#### 示例 3:
<pre>
<strong>输入:</strong> n = 50
<strong>输出:</strong> 564908303
</pre>

#### 提示:
* <code>1 <= n <= 10<sup>15</sup></code>

## 题解 (Rust)

### 1. 题解
```Rust
impl Solution {
    pub fn count_good_numbers(n: i64) -> i32 {
        fn twenty_pow(n: i64) -> i64 {
            if n == 0 {
                1
            } else if n % 2 == 0 {
                twenty_pow(n / 2) * twenty_pow(n / 2) % 1_000_000_007
            } else {
                twenty_pow(n - 1) * 20 % 1_000_000_007
            }
        }

        (match n % 2 {
            0 => twenty_pow(n / 2),
            _ => twenty_pow((n - 1) / 2) * 5 % 1_000_000_007,
        }) as i32
    }
}
```
