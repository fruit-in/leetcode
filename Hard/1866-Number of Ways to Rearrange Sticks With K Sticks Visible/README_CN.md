# 1866. 恰有 K 根木棍可以看到的排列数目
有 `n` 根长度互不相同的木棍，长度为从 `1` 到 `n` 的整数。请你将这些木棍排成一排，并满足从左侧 **可以看到** **恰好** `k` 根木棍。从左侧 **可以看到** 木棍的前提是这个木棍的 **左侧** 不存在比它 **更长的** 木棍。
* 例如，如果木棍排列为 `[1,3,2,5,4]` ，那么从左侧可以看到的就是长度分别为 `1`、`3` 、`5` 的木棍。

给你 `n` 和 `k` ，返回符合题目要求的排列 **数目** 。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> **取余** 的结果。

#### 示例 1:
<pre>
<strong>输入:</strong> n = 3, k = 2
<strong>输出:</strong> 3
<strong>解释:</strong> [1,3,2], [2,3,1] 和 [2,1,3] 是仅有的能满足恰好 2 根木棍可以看到的排列。
可以看到的木棍已经用粗体+斜体标识。
</pre>

#### 示例 2:
<pre>
<strong>输入:</strong> n = 5, k = 5
<strong>输出:</strong> 1
<strong>解释:</strong> [1,2,3,4,5] 是唯一一种能满足全部 5 根木棍可以看到的排列。
可以看到的木棍已经用粗体+斜体标识。
</pre>

#### 示例 3:
<pre>
<strong>输入:</strong> n = 20, k = 11
<strong>输出:</strong> 647427950
<strong>解释:</strong> 总共有 647427950 (mod 109 + 7) 种能满足恰好有 11 根木棍可以看到的排列。
</pre>

#### 提示:
* `1 <= n <= 1000`
* `1 <= k <= n`

## 题解 (Rust)

### 1. 题解
```Rust
impl Solution {
    pub fn rearrange_sticks(n: i32, k: i32) -> i32 {
        let mut dp0 = vec![0; n as usize + 1];

        for i in 1..=k as usize {
            let mut dp1 = vec![0; n as usize + 1];
            dp1[i] = 1;

            for j in i + 1..=n as usize {
                dp1[j] = (dp1[j - 1] as i64 * (j as i64 - 1) % 1_000_000_007) as i32
                    + dp0[j - 1] % 1_000_000_007;
            }

            dp0 = dp1;
        }

        dp0[n as usize] % 1_000_000_007
    }
}
```
